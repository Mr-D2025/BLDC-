# 解读逐飞代码
逐飞代码分老版与新版，两个版本有较大不同，这里两个都分析一下
## 逐飞代码（老版）
```c
//main.c
#include "motor.h"
#include "comparator.h"
#include "bldc_config.h"
#include "pwm.h"
#include "pwm_input.h"
#include "pit_timer.h"
#include "battery.h"
#include "headfile.h"



// 关于内核频率的设定，可以查看board.h文件
// 在board_init中,已经将P54引脚设置为复位
// 如果需要使用P54引脚,可以在board.c文件中的board_init()函数中删除SET_P54_RESRT即可

// 无刷电机LED状态灯说明
// 电池电压过低时，             LED亮0.1s    灭0.9s
// 电机遇到堵转，               LED亮0.05s   灭0.05s
// 电机未运行时，               LED亮1s      灭1s
// 电机开环启动中，             LED亮0.5s    灭0.5s
// 电机开环启动完成等待稳定中，  LED亮0.1s    灭0.1s
// 电机正常运行中，             LED常亮亮


void main()
{
    CKCON = 0;
    WTST = 0;               // 设置程序代码等待参数，赋值为0可将CPU执行程序的速度设置为最快
	  DisableGlobalIRQ();		// 关闭总中断
    sys_clk = 30000000;     // 设置系统频率为30000000Hz
  	board_init();			// 初始化寄存器
    EnableGlobalIRQ();		// 开启总中断
    download_flag = 0;
    
    // 此处编写用户代码(例如：外设初始化代码等)
    battery_init();         // 电池电压检测初始化
    led_init();             // LED初始化
    pwm_input_init();       // PWM输入捕获初始化
    comparator_init();      // 比较器初始化 
    motor_init();           // 电机相关初始化 

    // PWM初始化务必放在电机电机初始化函数之后，否则会烧毁电机
    // PWM初始化务必放在电机电机初始化函数之后，否则会烧毁电机
    // PWM初始化务必放在电机电机初始化函数之后，否则会烧毁电机
    pwm_center_init();      // PWM初始化 采用中心对齐         
	
  	pit_timer_init();       // 周期定时器初始化
	
    while(1)
	  {
    }
}

```
以上是老版的main.c文件，主要由一堆初始化组成，可以看到为了时效性，主要代码均在中断里面，此外与新版的最大区别在开启总中断时间不同。

```c

void board_init(void)
{
	EAXFR = 1;				// 使能访问XFR
	CKCON = 0x00;			// 设置外部数据总线为最快
	WTST = 0;               // 设置程序代码等待参数，赋值为0可将CPU执行程序的速度设置为最快
	SET_P54_RESRT;			// 使P54为复位引脚
	P_SW2 = 0x80;			// 开启特殊地址访问

#if (1 == EXTERNAL_CRYSTA_ENABLE)
	XOSCCR = 0xc0; 			//启动外部晶振
	while (!(XOSCCR & 1)); 	//等待时钟稳定
	CLKDIV = 0x00; 			//时钟不分频
	CLKSEL = 0x01; 			//选择外部晶振
#else
	//自动设置系统频率
	#if (0 == FOSC)
		sys_clk = set_clk();
	#else
		sys_clk = FOSC;
	#endif
#endif

	delay_init();			//延时函数初始化
	
	WTST = 0;
    P_SW2 |= 0x80;
    CLKDIV = 0;				//24MHz主频，分频设置
	
	P0M0 = 0x00;
	P0M1 = 0x00;
	P1M0 = 0x00;
	P1M1 = 0x00;
	P2M0 = 0x00;
	P2M1 = 0x00;
	P3M0 = 0x00;
	P3M1 = 0x00;
	P4M0 = 0x00;
	P4M1 = 0x00;
	P5M0 = 0x00;
	P5M1 = 0x00;
	P6M0 = 0x00;
	P6M1 = 0x00;
	P7M0 = 0x00;
	P7M1 = 0x00;
	
	ADCCFG = 0;
	AUXR = 0;
	SCON = 0;
	S2CON = 0;
	S3CON = 0;
	S4CON = 0;
	P_SW1 = 0;
	IE2 = 0;
	TMOD = 0;

	uart_init(DEBUG_UART, DEBUG_UART_RX_PIN, DEBUG_UART_TX_PIN, DEBUG_UART_BAUD, DEBUG_UART_TIM);
}
'''
这个函数是板子初始化函数，初始化了内存地址，时钟，引脚，以及一系列外设功能uart_init初始化下载程序用的串口。

```c
//-------------------------------------------------------------------------------------------------------------------
//  @brief      PWMB输入捕获初始化
//  @param      void                        
//  @return     void          
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void pwm_input_init(void)
{
    PWMB_PS = 0x0A;		// 通道引脚切换
    PWMB_CCMR1 = 0x01;	// CC5为输入模式,且映射到TI5FP5上
	PWMB_CCMR2 = 0x02;	// CC6为输入模式,且映射到TI5FP6上
    
	// CC5E 开启输入捕获
	// CC5P 捕获发生在TI5F的上升沿
	// CC6E 开启输入捕获
	// CC6P 捕获发生在TI5F的下降沿
    PWMB_CCER1 = 0x31;
    
    PWMB_PSCRH = 0;		// 分频值
	PWMB_PSCRL = sys_clk / 1000000 - 1;    // 分频值
    PWMB_SMCR = 0x54;	// TS=TI1FP1,SMS=TI1上升沿复位模式
	PWMB_CR1 = 0x01;	// 启动PWMB，向上计数
	PWMB_IER = 0x07;	// 使能CC1、CC2、UIE中断

    pwmin.period = 0;
    pwmin.high_value = 0;
    pwmin.high_time = 0;
}

```
这个函数配置了PWM输入捕获，测量外部ppm控制输入量，以相应的调速。

```c
//-------------------------------------------------------------------------------------------------------------------
//  @brief      比较器初始化
//  @param      void                        
//  @return     void          
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void comparator_init(void)
{
    gpio_mode(COMPARATOR_MID_PIN, GPI_IMPEDANCE); // 中性点
    gpio_mode(COMPARATOR_A_PIN  , GPI_IMPEDANCE); // A
	gpio_mode(COMPARATOR_B_PIN  , GPI_IMPEDANCE); // B
	gpio_mode(COMPARATOR_C_PIN  , GPI_IMPEDANCE); // C
    
    CMPCR1 = 0x8C;			// 1000 1100 打开比较器，P3.6作为比较器的反相输入端
	CMPCR2 = 63;				// 5个时钟滤波   比较结果变化延时周期数, 0~63
}


//-------------------------------------------------------------------------------------------------------------------
//  @brief      比较器中断函数
//  @param      void
//  @return     void
//  @since      v1.0
//  Sample usage:
//-------------------------------------------------------------------------------------------------------------------
void comparator_isr(void) interrupt 21		// 比较器中断函数, 检测到反电动势过0事件
{
    // 获取换相时间
    uint16 temp = (T4H << 8) | T4L;
    CMPCR1 &= ~0x40;	// 需软件清除中断标志位
	
// 去除反电动势毛刺
//    if((temp < (motor.commutation_time_sum / 24) && (30 * 7) < motor.commutation_num))
//    {
//        return;
//    }
	
    if(MOTOR_CLOSE_LOOP == motor.run_flag)
    {
        // 清空计数器
        T4T3M &= ~0x80; // 停止定时器
        T4L = 0;
        T4H = 0;
        T4T3M |= 0x80;  // 开启定时器
        // 去掉最早的数据
        motor.commutation_time_sum -= motor.commutation_time[motor.step];
        // 保存换相时间
        motor.commutation_time[motor.step] = temp;
        // 叠加新的换相时间，求6次换相总时长
        motor.commutation_time_sum += temp;
        motor.commutation_num++;
        // 本次换向60度的时间，在上一次换向一圈时间的50度到70度，否则认为换向错误
        if((temp > ((motor.commutation_time_sum / 36 * 5))) && (temp < (motor.commutation_time_sum / 36 * 7)))
        {
            // 延时减去换向失败计数器
            if((motor.commutation_failed_num))
            {
                motor.commutation_failed_num--;
            }
            // 缓慢加减速
            if(motor.duty != motor.duty_register)
            {
                if(0 == (motor.commutation_num%2) && (motor.duty_register != motor.duty))
                {
                    if(motor.duty > motor.duty_register)
                    {
                        motor.duty_register ++;
                        if(BLDC_MAX_DUTY < motor.duty_register)
                        {
                            motor.duty_register = BLDC_MAX_DUTY;
                        }
                    }
                    else
                    {
                        motor.duty_register = motor.duty;
                    }
                    pwm_center_duty_update(motor.duty_register);
                }
            }
        }
        else
        {
            if(BLDC_COMMUTATION_FAILED_MAX < motor.commutation_failed_num++)
            {
                motor_stop();
                motor.run_flag = MOTOR_STOP_STALL;
            }
        }
        // 修改PWM占空比

        motor_next_step();
        motor_commutation();
    }
}
```
比较器初始化以及比较器中断函数，在比较器中断函数中检测过零事件，这里仔细分析一下后者的逻辑。
首先，采用六步换向的方法，同一时刻只有两相有管子开通，此时使用另一相来进行反电动势检测，注意检测反电动势的相必须两个管子均关断，否则电压不对。
1.当反电动势过零的时候进入中断
2.进入中断后，获取中断事件，清除中断标志位
```c
// 获取换相时间
    uint16 temp = (T4H << 8) | T4L;
    CMPCR1 &= ~0x40;	// 需软件清除中断标志位
```
3.判断电机是否处于闭环模式

